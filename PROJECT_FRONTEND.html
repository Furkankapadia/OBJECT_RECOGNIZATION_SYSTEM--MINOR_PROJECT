<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Object Detection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: white;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1rem;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            flex: 1;
        }

        .camera-section, .results-section {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .section-title {
            color: white;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: 600;
        }

        #video {
            width: 100%;
            height: 400px;
            border-radius: 15px;
            background: #000;
            object-fit: cover;
            border: 3px solid rgba(255, 255, 255, 0.2);
        }

        #canvas {
            display: none;
        }

        .config-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .config-title {
            color: white;
            font-size: 1.1rem;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .config-row {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 10px;
        }

        .config-row label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.9rem;
            min-width: 120px;
        }

        .config-row input, .config-row select {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 0.9rem;
        }

        .config-row input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 10px;
        }

        .status-disconnected { background-color: #ff4757; }
        .status-connecting { background-color: #ffa502; }
        .status-connected { background-color: #2ed573; }

        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #4834d4, #686de0);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #00d2d3, #54a0ff);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            background: linear-gradient(45deg, #636e72, #74b9ff);
            cursor: not-allowed;
            transform: none;
            opacity: 0.6;
        }

        .results-container {
            height: 500px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            padding: 20px;
        }

        .detection-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 15px;
            color: white;
            border-left: 4px solid #4ECDC4;
            transition: all 0.3s ease;
        }

        .detection-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
        }

        .detection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .detection-class {
            font-size: 1.1rem;
            font-weight: 600;
            color: #4ECDC4;
        }

        .confidence-badge {
            background: rgba(76, 175, 80, 0.3);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            border: 1px solid rgba(76, 175, 80, 0.5);
        }

        .detection-details {
            font-size: 0.9rem;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.8);
        }

        .log-message {
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            border-left: 3px solid #636e72;
        }

        .log-success { border-left-color: #00b894; }
        .log-error { border-left-color: #e17055; }
        .log-info { border-left-color: #0984e3; }

        .loading {
            text-align: center;
            color: white;
            padding: 30px;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .no-results {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            padding: 40px;
            font-size: 1.1rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            color: white;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4ECDC4;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: 5px;
        }

        .upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
        }

        .upload-area:hover {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.1);
        }

        .upload-area.dragover {
            border-color: #4ECDC4;
            background: rgba(78, 205, 196, 0.1);
        }

        .upload-content {
            pointer-events: none;
        }

        .upload-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .upload-area p {
            color: white;
            margin: 0;
            font-size: 1rem;
        }

        .upload-area small {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.85rem;
        }

        .selected-files {
            margin-top: 15px;
            max-height: 120px;
            overflow-y: auto;
        }

        .file-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: white;
        }

        .file-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 10px;
        }

        .file-size {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.8rem;
            margin-right: 10px;
        }

        .remove-file {
            background: rgba(255, 75, 87, 0.3);
            border: none;
            color: white;
            border-radius: 4px;
            padding: 2px 6px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .remove-file:hover {
            background: rgba(255, 75, 87, 0.5);
        }

        .batch-progress {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: white;
        }

        .progress-bar {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            height: 8px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        .image-preview {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .preview-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.1);
        }

        .preview-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .preview-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .preview-item:hover .preview-overlay {
            opacity: 1;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }

            .image-preview {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîç AI Object Detection</h1>
        <p>Real-time object recognition powered by YOLO</p>
    </div>

    <div class="container">
        <div class="camera-section">
            <h2 class="section-title">üì∑ Camera Feed</h2>
            
            <video id="video" autoplay muted playsinline></video>
            <canvas id="canvas"></canvas>

            <div class="config-panel">
                <div class="config-title">üîß Configuration</div>
                
                <div class="config-row">
                    <label for="backendUrl">Backend URL:</label>
                    <input type="text" id="backendUrl" placeholder="Paste your ngrok URL here">
                    <span class="status-indicator status-disconnected" id="connectionStatus"></span>
                </div>

                <div class="config-row">
                    <label for="confidence">Min Confidence:</label>
                    <input type="range" id="confidence" min="0" max="1" step="0.05" value="0.5">
                    <span id="confidenceValue">50%</span>
                </div>

                <div class="config-row">
                    <label for="autoCapture">Auto Capture:</label>
                    <select id="autoCapture">
                        <option value="off">Off</option>
                        <option value="2">Every 2 seconds</option>
                        <option value="5">Every 5 seconds</option>
                    </select>
                </div>
            </div>

            <div class="controls">
                <button class="btn btn-secondary" id="testConnection">Test Connection</button>
                <button class="btn btn-success" id="startCamera">Start Camera</button>
                <button class="btn btn-primary" id="captureBtn" disabled>Capture & Detect</button>
            </div>

            <div class="config-panel">
                <div class="config-title">üìÅ Upload from Device</div>
                <div class="upload-area" id="uploadArea">
                    <input type="file" id="fileInput" accept="image/*" multiple style="display: none;">
                    <div class="upload-content">
                        <div class="upload-icon">üì∑</div>
                        <p>Click to select images or drag & drop</p>
                        <small>Supports: JPG, PNG, WebP</small>
                    </div>
                </div>
                <div class="selected-files" id="selectedFiles"></div>
                <button class="btn btn-primary" id="processFiles" style="width: 100%; margin-top: 15px;" disabled>
                    Process Selected Images
                </button>
            </div>
        </div>

        <div class="results-section">
            <h2 class="section-title">üéØ Detection Results</h2>
            
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-number" id="totalDetections">0</div>
                    <div class="stat-label">Total Detections</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="lastConfidence">0%</div>
                    <div class="stat-label">Avg Confidence</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="captureCount">0</div>
                    <div class="stat-label">Images Processed</div>
                </div>
            </div>

            <div class="results-container" id="resultsContainer">
                <div class="no-results">
                    <p>üëÜ Configure your ngrok URL and start detecting!</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let video, canvas, ctx, stream;
        let isCapturing = false;
        let autoCapture = null;
        let selectedFiles = [];
        let stats = {
            totalDetections: 0,
            captureCount: 0,
            avgConfidence: 0
        };

        // DOM elements
        const elements = {
            video: null,
            canvas: null,
            startCameraBtn: null,
            captureBtn: null,
            testConnectionBtn: null,
            resultsContainer: null,
            backendUrlInput: null,
            confidenceSlider: null,
            confidenceValue: null,
            autoCapture: null,
            connectionStatus: null,
            totalDetections: null,
            lastConfidence: null,
            captureCount: null,
            fileInput: null,
            uploadArea: null,
            selectedFiles: null,
            processFiles: null
        };

        // Initialize DOM elements
        document.addEventListener('DOMContentLoaded', () => {
            elements.video = document.getElementById('video');
            elements.canvas = document.getElementById('canvas');
            elements.startCameraBtn = document.getElementById('startCamera');
            elements.captureBtn = document.getElementById('captureBtn');
            elements.testConnectionBtn = document.getElementById('testConnection');
            elements.resultsContainer = document.getElementById('resultsContainer');
            elements.backendUrlInput = document.getElementById('backendUrl');
            elements.confidenceSlider = document.getElementById('confidence');
            elements.confidenceValue = document.getElementById('confidenceValue');
            elements.autoCapture = document.getElementById('autoCapture');
            elements.connectionStatus = document.getElementById('connectionStatus');
            elements.totalDetections = document.getElementById('totalDetections');
            elements.lastConfidence = document.getElementById('lastConfidence');
            elements.captureCount = document.getElementById('captureCount');
            elements.fileInput = document.getElementById('fileInput');
            elements.uploadArea = document.getElementById('uploadArea');
            elements.selectedFiles = document.getElementById('selectedFiles');
            elements.processFiles = document.getElementById('processFiles');

            ctx = elements.canvas.getContext('2d');
            
            setupEventListeners();
            addLogMessage('üöÄ Object Detection System Initialized', 'info');
        });

        // Setup event listeners
        function setupEventListeners() {
            elements.confidenceSlider.addEventListener('input', (e) => {
                elements.confidenceValue.textContent = Math.round(e.target.value * 100) + '%';
            });

            elements.autoCapture.addEventListener('change', (e) => {
                setupAutoCapture(e.target.value);
            });

            elements.testConnectionBtn.addEventListener('click', testConnection);
            elements.startCameraBtn.addEventListener('click', startCamera);
            elements.captureBtn.addEventListener('click', captureAndDetect);

            // File upload event listeners
            elements.uploadArea.addEventListener('click', () => elements.fileInput.click());
            elements.fileInput.addEventListener('change', handleFileSelect);
            elements.processFiles.addEventListener('click', processSelectedFiles);

            // Drag and drop
            elements.uploadArea.addEventListener('dragover', handleDragOver);
            elements.uploadArea.addEventListener('dragleave', handleDragLeave);
            elements.uploadArea.addEventListener('drop', handleFileDrop);
        }

        // Add log message
        function addLogMessage(message, type = 'info') {
            const logDiv = document.createElement('div');
            logDiv.className = `log-message log-${type}`;
            logDiv.innerHTML = `<strong>[${new Date().toLocaleTimeString()}]</strong> ${message}`;
            
            elements.resultsContainer.insertBefore(logDiv, elements.resultsContainer.firstChild);
            
            // Keep only last 10 log messages
            const logs = elements.resultsContainer.querySelectorAll('.log-message');
            if (logs.length > 10) {
                logs[logs.length - 1].remove();
            }
        }

        // Test backend connection
        async function testConnection() {
            const backendUrl = elements.backendUrlInput.value.trim();
            
            if (!backendUrl) {
                addLogMessage('‚ùå Please enter your ngrok URL first', 'error');
                return;
            }

            updateConnectionStatus('connecting');
            addLogMessage(`üîÑ Testing connection to: ${backendUrl}`, 'info');

            try {
                // First try with ngrok headers (this is what works based on debug)
                const response = await fetch(`${backendUrl}/`, {
                    method: 'GET',
                    headers: { 
                        'Accept': 'application/json',
                        'ngrok-skip-browser-warning': 'true',
                        'User-Agent': 'ObjectDetectionApp/1.0'
                    }
                });

                addLogMessage(`üì° Response status: ${response.status}`, 'info');
                const contentType = response.headers.get('content-type');
                addLogMessage(`üìÑ Content-Type: ${contentType}`, 'info');

                if (response.ok) {
                    const text = await response.text();
                    
                    // Try to parse as JSON
                    try {
                        const data = JSON.parse(text);
                        updateConnectionStatus('connected');
                        addLogMessage(`‚úÖ Backend connected successfully!`, 'success');
                        addLogMessage(`üìÑ Response: ${data.message}`, 'success');
                    } catch (jsonError) {
                        // If not JSON, check if it's HTML (ngrok warning)
                        if (text.includes('<html') || text.includes('ngrok')) {
                            updateConnectionStatus('disconnected');
                            addLogMessage(`‚ùå Getting HTML response instead of JSON`, 'error');
                            addLogMessage(`üí° Raw response: ${text.substring(0, 200)}...`, 'error');
                        } else {
                            updateConnectionStatus('connected');
                            addLogMessage(`‚úÖ Backend reachable but unexpected response format`, 'warning');
                            addLogMessage(`üìÑ Response: ${text}`, 'info');
                        }
                    }
                } else {
                    updateConnectionStatus('disconnected');
                    addLogMessage(`‚ùå Backend returned error: ${response.status}`, 'error');
                    const errorText = await response.text();
                    addLogMessage(`üìÑ Error details: ${errorText}`, 'error');
                }
            } catch (error) {
                updateConnectionStatus('disconnected');
                addLogMessage(`‚ùå Connection failed: ${error.message}`, 'error');
                
                if (error.message.includes('Failed to fetch')) {
                    addLogMessage(`üí° Network error - check if Colab is running`, 'error');
                } else if (error.message.includes('Unexpected token')) {
                    addLogMessage(`üí° Getting HTML instead of JSON - ngrok issue`, 'error');
                } else {
                    addLogMessage(`üí° Full error: ${error.toString()}`, 'error');
                }
            }
        }

        // Update connection status indicator
        function updateConnectionStatus(status) {
            elements.connectionStatus.className = `status-indicator status-${status}`;
        }

        // Start camera
        async function startCamera() {
            try {
                addLogMessage('üìπ Requesting camera access...', 'info');
                
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'environment'
                    }
                });
                
                elements.video.srcObject = stream;
                addLogMessage('‚úÖ Camera started successfully!', 'success');
                
                elements.startCameraBtn.disabled = true;
                elements.captureBtn.disabled = false;
                elements.startCameraBtn.textContent = 'Camera Active';
                
            } catch (error) {
                addLogMessage(`‚ùå Camera error: ${error.message}`, 'error');
            }
        }

        // Setup auto capture
        function setupAutoCapture(interval) {
            if (autoCapture) {
                clearInterval(autoCapture);
                autoCapture = null;
            }

            if (interval !== 'off' && !elements.captureBtn.disabled) {
                autoCapture = setInterval(() => {
                    if (!isCapturing) {
                        captureAndDetect();
                    }
                }, parseInt(interval) * 1000);
                
                addLogMessage(`üîÑ Auto capture enabled: every ${interval} seconds`, 'info');
            }
        }

        // Capture and detect
        async function captureAndDetect() {
            if (isCapturing) return;
            
            const backendUrl = elements.backendUrlInput.value.trim();
            if (!backendUrl) {
                addLogMessage('‚ùå Please enter your ngrok URL first', 'error');
                return;
            }

            isCapturing = true;
            elements.captureBtn.disabled = true;
            elements.captureBtn.textContent = 'Processing...';

            try {
                addLogMessage('üì∏ Capturing image...', 'info');
                
                // Set canvas size to match video
                elements.canvas.width = elements.video.videoWidth;
                elements.canvas.height = elements.video.videoHeight;
                
                // Draw current frame to canvas
                ctx.drawImage(elements.video, 0, 0);
                
                // Convert to blob
                const blob = await new Promise(resolve => {
                    elements.canvas.toBlob(resolve, 'image/jpeg', 0.8);
                });
                
                addLogMessage(`üìè Image captured: ${blob.size} bytes`, 'info');
                
                // Show loading
                showLoading();
                
                // Send to backend
                await detectObjects(backendUrl, blob);
                
                // Update stats
                stats.captureCount++;
                elements.captureCount.textContent = stats.captureCount;
                
            } catch (error) {
                addLogMessage(`‚ùå Capture error: ${error.message}`, 'error');
            } finally {
                hideLoading();
                isCapturing = false;
                elements.captureBtn.disabled = false;
                elements.captureBtn.textContent = 'Capture & Detect';
            }
        }

        // Show loading spinner
        function showLoading() {
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading';
            loadingDiv.id = 'loading';
            loadingDiv.innerHTML = `
                <div class="spinner"></div>
                <p>ü§ñ AI is analyzing the image...</p>
            `;
            elements.resultsContainer.appendChild(loadingDiv);
        }

        // Hide loading spinner
        function hideLoading() {
            const loading = document.getElementById('loading');
            if (loading) loading.remove();
        }

        // Detect objects
        async function detectObjects(backendUrl, imageBlob) {
            try {
                addLogMessage(`üöÄ Sending to AI backend...`, 'info');
                
                const formData = new FormData();
                formData.append('file', imageBlob, 'capture.jpg');
                
                const response = await fetch(`${backendUrl}/predict`, {
                    method: 'POST',
                    body: formData
                });
                
                addLogMessage(`üì° Response status: ${response.status}`, 'info');
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const result = await response.json();
                addLogMessage(`üìÑ Received ${result.predictions?.length || 0} predictions`, 'success');
                
                displayResults(result);
                
            } catch (error) {
                addLogMessage(`‚ùå Detection failed: ${error.message}`, 'error');
                
                if (error.message.includes('Failed to fetch')) {
                    addLogMessage(`üí° Tip: Check if your Colab is still running`, 'error');
                } else if (error.message.includes('404')) {
                    addLogMessage(`üí° Tip: Make sure the endpoint is /predict`, 'error');
                } else if (error.message.includes('500')) {
                    addLogMessage(`üí° Tip: Check Colab logs for model errors`, 'error');
                }
            }
        }

        // Display detection results
        function displayResults(result) {
            // Clear previous detection items (keep logs)
            const existingDetections = elements.resultsContainer.querySelectorAll('.detection-item');
            existingDetections.forEach(item => item.remove());
            
            const predictions = result.predictions || [];
            const minConfidence = parseFloat(elements.confidenceSlider.value);
            
            // Filter by confidence
            const validPredictions = predictions.filter(pred => pred.confidence >= minConfidence);
            
            if (validPredictions.length > 0) {
                addLogMessage(`‚úÖ Found ${validPredictions.length} objects above ${Math.round(minConfidence * 100)}% confidence!`, 'success');
                
                // Update stats
                stats.totalDetections += validPredictions.length;
                const avgConf = validPredictions.reduce((sum, pred) => sum + pred.confidence, 0) / validPredictions.length;
                stats.avgConfidence = avgConf;
                
                elements.totalDetections.textContent = stats.totalDetections;
                elements.lastConfidence.textContent = Math.round(avgConf * 100) + '%';
                
                validPredictions.forEach((prediction, index) => {
                    const detectionDiv = document.createElement('div');
                    detectionDiv.className = 'detection-item';
                    
                    const confidence = Math.round(prediction.confidence * 100);
                    const bbox = prediction.bbox[0]; // YOLO returns nested array
                    
                    detectionDiv.innerHTML = `
                        <div class="detection-header">
                            <span class="detection-class">üéØ ${prediction.class}</span>
                            <span class="confidence-badge">${confidence}%</span>
                        </div>
                        <div class="detection-details">
                            <strong>Position:</strong> (${Math.round(bbox[0])}, ${Math.round(bbox[1])}) to (${Math.round(bbox[2])}, ${Math.round(bbox[3])})<br>
                            <strong>Size:</strong> ${Math.round(bbox[2] - bbox[0])}√ó${Math.round(bbox[3] - bbox[1])} pixels<br>
                            <strong>Detection #:</strong> ${stats.totalDetections - validPredictions.length + index + 1}
                        </div>
                    `;
                    
                    elements.resultsContainer.appendChild(detectionDiv);
                });
            } else {
                addLogMessage(`‚ÑπÔ∏è No objects detected above ${Math.round(minConfidence * 100)}% confidence`, 'info');
                
                const noResultsDiv = document.createElement('div');
                noResultsDiv.className = 'detection-item';
                noResultsDiv.innerHTML = `
                    <div class="detection-header">
                        <span class="detection-class">üîç No Objects Found</span>
                    </div>
                    <div class="detection-details">
                        Try lowering the confidence threshold or ensuring objects are clearly visible.
                    </div>
                `;
                elements.resultsContainer.appendChild(noResultsDiv);
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            if (autoCapture) {
                clearInterval(autoCapture);
            }
        });

        // File handling functions
        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            addFiles(files);
        }

        function handleDragOver(event) {
            event.preventDefault();
            elements.uploadArea.classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            elements.uploadArea.classList.remove('dragover');
        }

        function handleFileDrop(event) {
            event.preventDefault();
            elements.uploadArea.classList.remove('dragover');
            const files = Array.from(event.dataTransfer.files);
            const imageFiles = files.filter(file => file.type.startsWith('image/'));
            addFiles(imageFiles);
        }

        function addFiles(files) {
            const validFiles = files.filter(file => {
                // Check file type
                if (!file.type.startsWith('image/')) return false;
                // Check file size (max 10MB)
                if (file.size > 10 * 1024 * 1024) {
                    addLogMessage(`‚ö†Ô∏è File ${file.name} is too large (max 10MB)`, 'error');
                    return false;
                }
                // Check if already selected
                if (selectedFiles.some(f => f.name === file.name && f.size === file.size)) {
                    return false;
                }
                return true;
            });

            selectedFiles = [...selectedFiles, ...validFiles];
            updateFileList();
            
            if (validFiles.length > 0) {
                addLogMessage(`üìÅ Added ${validFiles.length} image(s) for processing`, 'success');
            }
        }

        function removeFile(index) {
            selectedFiles.splice(index, 1);
            updateFileList();
            addLogMessage('üóëÔ∏è File removed', 'info');
        }

        function updateFileList() {
            elements.selectedFiles.innerHTML = '';
            
            if (selectedFiles.length === 0) {
                elements.processFiles.disabled = true;
                return;
            }

            elements.processFiles.disabled = false;
            
            // Create file list
            selectedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                
                const sizeText = formatFileSize(file.size);
                
                fileItem.innerHTML = `
                    <span class="file-name">${file.name}</span>
                    <span class="file-size">${sizeText}</span>
                    <button class="remove-file" onclick="removeFile(${index})">‚úï</button>
                `;
                
                elements.selectedFiles.appendChild(fileItem);
            });

            // Create image preview
            if (selectedFiles.length <= 6) { // Show preview only for few files
                createImagePreviews();
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function createImagePreviews() {
            const previewContainer = document.createElement('div');
            previewContainer.className = 'image-preview';
            
            selectedFiles.forEach((file, index) => {
                const previewItem = document.createElement('div');
                previewItem.className = 'preview-item';
                
                const img = document.createElement('img');
                img.className = 'preview-img';
                img.src = URL.createObjectURL(file);
                img.onload = () => URL.revokeObjectURL(img.src);
                
                const overlay = document.createElement('div');
                overlay.className = 'preview-overlay';
                overlay.innerHTML = `<small>${file.name}</small>`;
                
                previewItem.appendChild(img);
                previewItem.appendChild(overlay);
                previewContainer.appendChild(previewItem);
            });
            
            elements.selectedFiles.appendChild(previewContainer);
        }

        async function processSelectedFiles() {
            if (selectedFiles.length === 0) return;
            
            const backendUrl = elements.backendUrlInput.value.trim();
            if (!backendUrl) {
                addLogMessage('‚ùå Please enter your ngrok URL first', 'error');
                return;
            }

            elements.processFiles.disabled = true;
            elements.processFiles.textContent = 'Processing...';

            // Create progress tracking
            const progressDiv = document.createElement('div');
            progressDiv.className = 'batch-progress';
            progressDiv.innerHTML = `
                <div><strong>Processing ${selectedFiles.length} images...</strong></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div id="progressText">0 / ${selectedFiles.length} completed</div>
            `;
            elements.resultsContainer.appendChild(progressDiv);

            let processedCount = 0;
            let totalDetections = 0;

            try {
                for (let i = 0; i < selectedFiles.length; i++) {
                    const file = selectedFiles[i];
                    addLogMessage(`üì∏ Processing ${file.name} (${i + 1}/${selectedFiles.length})`, 'info');
                    
                    try {
                        const result = await detectObjectsFromFile(backendUrl, file);
                        const validPredictions = (result.predictions || []).filter(
                            pred => pred.confidence >= parseFloat(elements.confidenceSlider.value)
                        );
                        
                        totalDetections += validPredictions.length;
                        processedCount++;
                        
                        // Update progress
                        const progressFill = document.getElementById('progressFill');
                        const progressText = document.getElementById('progressText');
                        if (progressFill && progressText) {
                            const percent = (processedCount / selectedFiles.length) * 100;
                            progressFill.style.width = `${percent}%`;
                            progressText.textContent = `${processedCount} / ${selectedFiles.length} completed`;
                        }
                        
                        // Display results for this file
                        displayBatchResult(file.name, validPredictions, i + 1);
                        
                        // Small delay to prevent overwhelming the server
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                    } catch (error) {
                        addLogMessage(`‚ùå Error processing ${file.name}: ${error.message}`, 'error');
                        processedCount++;
                    }
                }

                // Update overall stats
                stats.totalDetections += totalDetections;
                stats.captureCount += selectedFiles.length;
                elements.totalDetections.textContent = stats.totalDetections;
                elements.captureCount.textContent = stats.captureCount;

                addLogMessage(`‚úÖ Batch processing complete! Found ${totalDetections} objects in ${processedCount} images`, 'success');
                
                // Clear selected files after processing
                selectedFiles = [];
                updateFileList();

            } catch (error) {
                addLogMessage(`‚ùå Batch processing failed: ${error.message}`, 'error');
            } finally {
                elements.processFiles.disabled = false;
                elements.processFiles.textContent = 'Process Selected Images';
                
                // Remove progress bar after completion
                setTimeout(() => {
                    const progressDiv = document.querySelector('.batch-progress');
                    if (progressDiv) progressDiv.remove();
                }, 3000);
            }
        }

        async function detectObjectsFromFile(backendUrl, file) {
            const formData = new FormData();
            formData.append('file', file);
            
            const response = await fetch(`${backendUrl}/predict`, {
                method: 'POST',
                body: formData,
                headers: {
                    'ngrok-skip-browser-warning': 'true',
                    'User-Agent': 'ObjectDetectionApp/1.0'
                }
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }
            
            return await response.json();
        }

        function displayBatchResult(fileName, predictions, fileIndex) {
            if (predictions.length === 0) return;
            
            const batchResultDiv = document.createElement('div');
            batchResultDiv.className = 'detection-item';
            batchResultDiv.style.borderLeft = '4px solid #ff6b6b';
            
            const avgConfidence = predictions.reduce((sum, pred) => sum + pred.confidence, 0) / predictions.length;
            
            batchResultDiv.innerHTML = `
                <div class="detection-header">
                    <span class="detection-class">üìÅ ${fileName}</span>
                    <span class="confidence-badge">${predictions.length} objects</span>
                </div>
                <div class="detection-details">
                    <strong>Detected Objects:</strong> ${predictions.map(p => `${p.class} (${Math.round(p.confidence * 100)}%)`).join(', ')}<br>
                    <strong>Average Confidence:</strong> ${Math.round(avgConfidence * 100)}%<br>
                    <strong>File #:</strong> ${fileIndex}
                </div>
            `;
            
            elements.resultsContainer.appendChild(batchResultDiv);
        }

        // Make removeFile function global so it can be called from onclick
        window.removeFile = removeFile;
    </script>
</body>
</html>